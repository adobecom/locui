import{i as t,_ as e,e as o,a as i,s as n,x as r,c as a}from"./1bd6a5fb.js";const s=(t,e,o)=>{const i=t.createShader(o);if(null!=i&&(t.shaderSource(i,e),t.compileShader(i),!t.getShaderParameter(i,t.COMPILE_STATUS)))throw new Error(`An error occurred compiling the shaders: ${t.getShaderInfoLog(i)}`);return i},l=t=>{t.clearColor(0,0,0,0),t.blendFunc(t.SRC_ALPHA,t.ONE_MINUS_SRC_ALPHA),t.enable(t.BLEND),t.clear(t.COLOR_BUFFER_BIT);const e=((t,e,o)=>{const i=t.createProgram();if(null!==i){const n=s(t,e,t.VERTEX_SHADER),r=s(t,o,t.FRAGMENT_SHADER);null!==n&&t.attachShader(i,n),null!==r&&t.attachShader(i,r),t.linkProgram(i)}if(null===i||!t.getProgramParameter(i,t.LINK_STATUS))throw new Error("Unable to initialize the shader program.");return i})(t,"\nattribute vec4 a_position;\nvarying vec2 v_position;\n\nvoid main() {\n  v_position = vec2(a_position.z, 1.0 - a_position.w);\n  gl_Position = vec4(a_position.x, a_position.y, 0, 1);\n}\n","\nprecision highp float;\n\nuniform vec2 u_outsize;\nvarying vec2 v_position;\nuniform sampler2D texTest;\nuniform vec2 texTestSize;\nuniform vec2 texTranslate;\nuniform float docScale;\nuniform float texScale;\nuniform float cycleOffset;\nuniform int drawMode;\n\nfloat getSelectionValue(vec2 position) {\n  vec4 col = texture2D(texTest, position);\n  return col.r;\n}\n\nvoid main(void)\n{\n    vec2 outPixelDelta = vec2(1.0, 1.0) / u_outsize;\n    // output fragment position in pixels\n    vec2 outPos = v_position * u_outsize;\n\n    // actual size of the ants texture (rowBytes is true width including uninitialized columns, texTestSize.x is width of usable data)\n    vec2 texTrueSize = vec2(texTestSize.x, texTestSize.y);\n    vec2 texTrueScalar = texTestSize / texTrueSize;\n\n    // texel size\n    vec2 texDelta = vec2(1.0,1.0)/(texTestSize * texScale);\n    vec2 texTrueDelta = texDelta * texTrueScalar;\n\n    // fragment position after transform in pixels\n    vec2 finalPosition = (outPos - texTranslate) / texScale;\n\n    // position within ants texture\n    vec2 texPosition = finalPosition/texTestSize;\n    vec2 texTruePosition = finalPosition/texTrueSize;\n    vec4 emptyColor = vec4(0.0,0.0,0.0,0.0);\n\n    vec4 finalColor = emptyColor;\n\n    float col = getSelectionValue(texTruePosition);\n\n    if (drawMode > 0) {\n      if ((finalPosition.x >= 0.0) && (finalPosition.x < texTestSize.x) && (finalPosition.y >= 0.0) && (finalPosition.y < texTestSize.y)) {\n        if (drawMode == 1)\n          finalColor = vec4(1.0, 0.0, 0.0, (1.0 - col) * 0.5);\n        if (drawMode == 2)\n          finalColor = vec4(0.0, 0.0, 0.0, (1.0 - col) * 0.5);\n        if (drawMode == 3)\n          finalColor = vec4(1.0, 1.0, 1.0, (1.0 - col) * 0.5);\n        if (drawMode == 4) {\n          float gray = col;\n          finalColor = vec4(gray, gray, gray, 1.0);\n        }\n      }\n    }\n\n    gl_FragColor = finalColor;\n\n    if (drawMode == 0) {\n\n      // ---- Ants drawing ---\n\n      // determine if we are inside or outside the ants texture\n      float texOut = texPosition.x < 0.0 ? 0.0 : (texPosition.x > 1.0 ? 0.0 : 1.0);\n      texOut = texOut * (texPosition.y < 0.0 ? 0.0 : (texPosition.y > 1.0 ? 0.0 : 1.0));\n\n      // determine if the samples around the fragment are inside/outside the ants texture\n      vec2 t1p = texPosition + vec2(-texDelta.x, 0);\n      float t1o = t1p.x < 0.0 ? 0.0 : (t1p.x > 1.0 ? 0.0 : 1.0);\n      t1o = t1o * (t1p.y < 0.0 ? 0.0 : (t1p.y > 1.0 ? 0.0 : 1.0));\n      vec2 t2p = texPosition + vec2(0, -texDelta.y);\n      float t2o = t2p.x < 0.0 ? 0.0 : (t2p.x > 1.0 ? 0.0 : 1.0);\n      t2o = t2o * (t2p.y < 0.0 ? 0.0 : (t2p.y > 1.0 ? 0.0 : 1.0));\n      vec2 t3p = texPosition + vec2(texDelta.x, 0);\n      float t3o = t3p.x < 0.0 ? 0.0 : (t3p.x > 1.0 ? 0.0 : 1.0);\n      t3o = t3o * (t3p.y < 0.0 ? 0.0 : (t3p.y > 1.0 ? 0.0 : 1.0));\n      vec2 t4p = texPosition + vec2(0, texDelta.y);\n      float t4o = t4p.x < 0.0 ? 0.0 : (t4p.x > 1.0 ? 0.0 : 1.0);\n      t4o = t4o * (t4p.y < 0.0 ? 0.0 : (t4p.y > 1.0 ? 0.0 : 1.0));\n\n      // sample from the ants texture - be sure to use actual coordinates within the texture\n      float c1 = getSelectionValue(texTruePosition + vec2(-texTrueDelta.x, 0));\n      float c2 = getSelectionValue(texTruePosition + vec2(0, -texTrueDelta.y));\n      float c3 = getSelectionValue(texTruePosition + vec2(texTrueDelta.x, 0));\n      float c4 = getSelectionValue(texTruePosition + vec2(0, texTrueDelta.y));\n\n      float s1 = clamp(floor(col * texOut + 0.5), 0.0, 1.0);\n      float s2 = clamp(floor(1.0 - c1 * t1o + 0.5), 0.0, 1.0);\n      float s3 = clamp(floor(1.0 - c2 * t2o + 0.5), 0.0, 1.0);\n      float s4 = clamp(floor(1.0 - c3 * t3o + 0.5), 0.0, 1.0);\n      float s5 = clamp(floor(1.0 - c4 * t4o + 0.5), 0.0, 1.0);\n\n      float solid = s1 * (s2 + s3 + s4 + s5);\n      solid = clamp(solid, 0.0, 1.0);\n\n      float patt = floor((mod(floor(outPos.y + outPos.x + cycleOffset), 8.0)/8.0) + 0.5);\n      patt = clamp(patt, 0.0, 1.0);\n      vec4 sel1Color = vec4(1.0,1.0,1.0,1.0);\n      vec4 sel2Color = vec4(0.0,0.0,0.0,1.0);\n\n      if (solid > 0.0)\n        gl_FragColor = (sel1Color * patt + sel2Color * (1.0 - patt)) * solid + emptyColor * (1.0 - solid);\n      /*\n      // Uncomment to DEBUG\n      else\n        gl_FragColor = vec4(col, texOut, 0.0, 0.3);\n      */\n    }\n  }\n");if(e){t.useProgram(e);const o=t.getAttribLocation(e,"a_position");return t.enableVertexAttribArray(o),(t=>{const e=t.createBuffer();t.bindBuffer(t.ARRAY_BUFFER,e),t.bufferData(t.ARRAY_BUFFER,new Float32Array([-1,-1,0,0,1,-1,1,0,-1,1,0,1,-1,1,0,1,1,-1,1,0,1,1,1,1]),t.STATIC_DRAW)})(t),{shaderProgram:e,vertexPositionAttribute:o}}return null};var c;!function(t){t[t.ANTS=0]="ANTS",t[t.OVERLAY=1]="OVERLAY",t[t.BLACK=2]="BLACK",t[t.WHITE=3]="WHITE",t[t.BLACK_WHITE=4]="BLACK_WHITE"}(c||(c={}));class h extends n{set imageUrl(t){if(""!==t){const e=document.createElement("img");e.onload=()=>{if(this.canvasElement||(this.canvasElement=document.createElement("canvas"),this.canvasElement.id="pixels"),this.canvasElement.width=e.width,this.canvasElement.height=e.height,this.gl=(t=>{let e=null;try{const o={alpha:!0,stencil:!1,depth:!1,antialias:!1,powerPreference:"high-performance"};e=t.getContext("webgl",o)||t.getContext("experimental-webgl",o)}catch(t){throw new Error("Error: No Web GL")}return e})(this.canvasElement),this.gl){const t=l(this.gl);if(t){this.shaderProgram=t.shaderProgram,this.gl.vertexAttribPointer(t.vertexPositionAttribute,4,this.gl.FLOAT,!1,0,0),this.texture=((t,e)=>{const o=t.createTexture();return t.bindTexture(t.TEXTURE_2D,o),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.NEAREST),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.NEAREST),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,e),o})(this.gl,e);const o=()=>{this.drawGL(0,0,1,1,this.visible),requestAnimationFrame(o)};requestAnimationFrame(o)}}},e.src=t,this._imageUrl=t}}get imageUrl(){return this._imageUrl}constructor(){super(),this._imageUrl="",this.cycleOffset=0,this.visible=!0,this.imageUrl="",this.tx=0,this.ty=0,this.drawMode=c.ANTS}drawGL(t,e,o,i,n){if(this.gl&&!this.gl.isContextLost()&&this.shaderProgram&&this.canvasElement&&(this.gl.viewport(0,0,this.canvasElement.width,this.canvasElement.height),this.gl.clear(this.gl.COLOR_BUFFER_BIT),n&&this.texture)){this.gl.useProgram(this.shaderProgram);const n=this.gl.getUniformLocation(this.shaderProgram,"texTest");this.gl.activeTexture(this.gl.TEXTURE0),this.gl.bindTexture(this.gl.TEXTURE_2D,this.texture),this.gl.uniform1i(n,0);const r=this.gl.getUniformLocation(this.shaderProgram,"texTestSize");r&&this.gl.uniform2f(r,this.canvasElement.width,this.canvasElement.height);const a=this.gl.getUniformLocation(this.shaderProgram,"u_outsize");this.gl.uniform2f(a,this.canvasElement.width,this.canvasElement.height);const s=this.gl.getUniformLocation(this.shaderProgram,"texTranslate");s&&this.gl.uniform2f(s,t,e);const l=this.gl.getUniformLocation(this.shaderProgram,"docScale");l&&this.gl.uniform1f(l,o);const c=this.gl.getUniformLocation(this.shaderProgram,"texScale");c&&this.gl.uniform1f(c,i);const h=this.gl.getUniformLocation(this.shaderProgram,"cycleOffset");h&&this.gl.uniform1f(h,this.cycleOffset),this.cycleOffset-=.05;const u=this.gl.getUniformLocation(this.shaderProgram,"drawMode");u&&this.gl.uniform1i(u,this.drawMode),this.gl.drawArrays(this.gl.TRIANGLES,0,6)}}render(){const t={transform:"none",display:"block"};return(this.tx||this.ty)&&(t.transform=`translate(${this.tx||0}px, ${this.ty||0}px)`),this.visible||(t.display="none"),r` <div class="container" style="${a(t)}"> ${this.canvasElement} </div> `}}h.styles=[t`:host{display:block;width:min-content;height:min-content}img{display:block;pointer-events:none}`],e([o({attribute:!1})],h.prototype,"visible",void 0),e([o({reflect:!0})],h.prototype,"drawMode",void 0),e([o({attribute:!1})],h.prototype,"canvasElement",void 0),e([o({attribute:!1})],h.prototype,"imageUrl",null),e([o({attribute:!1})],h.prototype,"tx",void 0),e([o({attribute:!1})],h.prototype,"ty",void 0),e([o({attribute:!1})],h.prototype,"gl",void 0),e([o({attribute:!1})],h.prototype,"texture",void 0),e([o({attribute:!1})],h.prototype,"shaderProgram",void 0),e([o({attribute:!1})],h.prototype,"cycleOffset",void 0),e([i("img#image")],h.prototype,"imageElement",void 0);export{h as F};
